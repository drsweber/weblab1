<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Олеся Сердобинцева</title>
    
<link rel="stylesheet" href="style/bootstrap.css">
<link rel="stylesheet" href="style/style.css" type="text/css"/>
</head>
<body>

<div class="container">
    <div class="row">
        <div class="col-md-10">
            <h1>Система доменных имен DNS</h1>
            <p>Материалы книги П.Б. Храмцова </p>
        </div>
            
            <div class="col-md-2">
                    <button type="button" id="first-button" class="btn btn-outline-secondary" data-toggle="modal" data-target="#myModal">Нажми на меня</button>
                    <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModal" aria-hidden="true">
                        <div class="modal-dialog" role="document">
                            <div class="modal-content">
                                <div class="modal-header">
                                <h5 class="modal-title" id="myModal">Заполните форму</h5>
                                <button class="close" data-dismiss="modal" aria-label="close">
                                    <span aria-hidden="true">&times;</span>
                                </button>
                                </div>
                                <div class="modal-body">
                                <form role="form">
                                    <div class="form-group">
                                        <label for="name">Имя:</label>
                                        <input type="name" class="form-control" id="name" placeholder="Ваше имя">
                                        <label for="email">E-mail</label>
                                        <input type="email" class="form-control" id="email" placeholder="Ваш E-mail">
                                        <label for="password">Пароль:</label>
                                        <input type="password" class="form-control" id="password" placeholder="Ваш пароль">
                                        <label for="Checkbox">
                                        <input type="checkbox" id="checkbox"> Запомнить меня
                                        </label>
                                    </div>
                                </form>
                                </div>
                                <div class="modal-footer">
                                <button class="btn secondary" data-dismiss="modal">Закрыть</button>
                                <button class="btn btn-primary" data-dismiss="modal">Готово</button>                             
                                </div>
                            </div>
                        </div>
                    </div>
            </div>
    </div>
    <div class="contanier-fluid">
        <div id="carouselExamplelIndicators" class="carousel slide">
            <ol class="carousel-indicators">
                <li class="active" data-target="#carouselExamplelIndicators" data-slide-to="0"></li>
                <li data-target="#carouselExamplelIndicators" data-slide-to="1"></li>
                <li data-target="#carouselExamplelIndicators" data-slide-to="2"></li>
            </ol>
            <div class="carousel-inner">
                <div class="carousel-item active">
                    <img src="pic/dns1.jpg" class="d-block w-100">
                </div>
                <div class="carousel-item">
                        <img src="pic/dns3.jpg" class="d-block w-100">
                </div>
                <div class="carousel-item">
                        <img src="pic/dns2.jpg" class="d-block w-100">
                </div>
            </div>
            <a href="#carouselExamplelIndicators" class="carousel-control-prev" role="button" data-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="sr-only">Предыдущая</span>
            </a>
            <a href="#carouselExamplelIndicators" class="carousel-control-next" role="button" data-slide="next">
                    <span class="carousel-control-next-icon" aria-hidden="true"></span>
                    <span class="sr-only">Следующая</span>
                </a>
        </div>
    </div>
    <h2> Как работает система доменных имён?</h2>
    <i>В данном материале речь пойдет о схеме взаимодействия между различными компонентами системы доменных имен при выполнении ею
     своей основной функции, а именно обслуживания запросов на установление соответствия между доменными именами и IP-адресами.</i>
     <p> </p>
     <p align=justify>Согласно руководящим материалам (RFC-1034, RFC-1035) система доменных имен состоит из трех основных частей:</p>
            <ul>
            <li>Всего множества доменных имен (domain name space)</li>
            <li>Серверов доменных имен (domain name servers)</li>
            <li>Клиенты DNS (Resolver-ы)</li>
            </ul>

    <p align=justify> Сервис системы доменных имен строится по схеме "клиент-сервер". В качестве клиентской части выступает прикладной процесс, 
        который запрашивает информацию о соответствии имени адресу (или наоборот адреса имени). Это программное обеспечение и 
        называют resolver. В качестве сервера выступает прикладная программа-сервер.</p>
    <p align=justify>Чаще всего, Resolver не является какой-либо программой или системной компонентой. Это набор процедур из  
        библиотеки прикладного программного обеспечения (например, из библиотеки libc), которые позволяют программе, отредактированной
         с ними, выполнять запросы к системе доменных имен и получать ответы на них. Эти процедуры обращаются к серверу доменных имен и, 
         таким образом, обслуживает запросы прикладных программ пользователя. </p>
    <p align=justify>Ряд производителей операционных систем, например, Sun или SGI, предлагали решения, в которых resolver являлся 
        отдельным процессом, и прикладные программы через него реализовывали взаимодействие с DNS.</p>
    <p align=justify>Другой пример реализации resolver-а - это браузеры Nescape некоторых версий, где для ускорения процесса получения 
        ответов на запросы к DNS запускался отдельный процесс resolver-a.</p>
    <p align=justify>Самостоятельный resolver может быть собран и в BIND версии 9. Это так называемый lightweight resolver. Он состоит 
        из resolver-демона и библиотеки взаимодействия с этим демоном, процедуры которой линкуются с прикладным ПО. Данный resolver 
        позволяет не только посылать запросы к серверу доменных имен, но кэшировать соответствия между доменным именем и IP-адресом.</p>
    <p align=justify>В качестве серверов доменных имен чаще всего используются различные версии BIND (Berkeley Internet Name Domain). Если сервер
         реализован на платформе Windows, то тогда используют решение от Microsoft, хотя для этой платформы также существуют версии BIND.</p>
    <p align=justify>Общую схему взаимодействия различных компонентов системы доменных имен можно изобразить так, как это представлено 
        на следующем рисунке:</p>
        <figure class="sign">     
        <img src="pic/pic1.jpg">
        <figcaption><i>Рис1. Рекурсивный запрос resolver и нерекурсивная (итеративная) процедура на разрешение доменного имени сервером доменных 
        имен.</i></figcaption>
        </figure>

    <p align=justify>Данная схема разрешения имени (установки соответствия между именем и IP-адресом) называют нерекурсивной (итеративной). Чем она отличается от рекурсивной мы обсудим позже.


            <p align=justify>Поясним приведенную схему нерекурсивной процедуры разрешения запроса:</p>
            <ol>
            <li>Прикладная программа через resolver запрашивает IP-адрес по доменному имени у местного сервера (запрос resolver рекурсивный, 
                т.е. resolver просит server найти ему адрес).</li>
            <li>Местный сервер сообщает прикладной программе IP-адрес запрошенного имени, выполняя при этом нерекурсивный опрос серверов доменных 
                имен. При этом:</li>
            <ol style="list-style-type:lower-alpha;">
            <li>если адрес находится в зоне его (местного сервера) ответственности, сразу сообщает его resolver-у,</li>
            <li>если адрес находится в зоне ответственности другого сервера доменных имен, то обращается к корневому серверу системы доменных имен
                 за адресом TLD-сервера (top-level domain server),</li>
            <li>обращается к TLD-серверу за адресом,</li>
            <li>получает от него адрес удаленного сервера,</li>
            <li>обращается к удаленному серверу за адресом,</li>
            <li>получает от удаленного сервера адрес,</li>
            </ol>
            </ol>
            <p align=justify>В данном случае мы рассмотрели вложенность доменного имени второго порядка., т.е. хост имел имя похожее на 
                quest.kuku.ru или даже kuku.ru.</p>
            <p align=justify>Последнее важно понять, т.к. корпоративные почтовые адреса типа user@kuku.ru как раз и требуют от прикладного 
                программного обеспечения обращения за IP-адресом хоста kuku.ru. TLD-сервер домена ru не обладает информацией о том, какому 
                IP-адресу данное имя соответствует, но при этом он знает какой сервер отвечает за домен kuku.ru.</p>
            <p align=justify>Если вложенность доменного имени будет большей, скажем третьего уровня (host.department.corp.ru), и этот 
                уровень будет поддерживаться другим сервером доменных имен, отличным от того, который поддерживает второй уровень 
                вложенности, то тогда нашему локальному серверу удаленный сервер доменных имен передаст не адрес хоста, а адрес нового 
                сервера доменных имен, в зоне ответственности которого находится запрашиваемое имя.</p>         
            <p align=justify>Как видно из приведенной схемы, получение информации из системы доменных имен - это многоходовой процесс, 
                который не реализуется мгновенно. В следующем примере показано как на практике ощущается работа DNS.</p>           
            <p align=justify>При входе в режиме удаленного терминала на компьютер polyn.net.kiae.su по команде:</p>           
            <pre>
            /usr/paul>telnet polyn.net.kiae.su
            </pre>
            <p align=justify>Мы получаем в ответ:</p>
            <pre>
            /usr/paul>telnet polyn.net.kiae.su
            trying 144.206.130.137 ...
            login:
            .....
            </pre>
            <p align=justify>Строчка, в которой указан IP-адрес компьютера polyn.net.kiae.su, показывает, что к этому времени доменное 
                имя было успешно разрешено сервером доменных имен и прикладная программа, в данном случае telnet получила на свой запрос 
                IP-адрес. Таким образом, после ввода команды с консоли, и до появления IP-адреса на экране монитора прикладная программа 
                осуществила запрос к серверу доменных имен и получила ответ на него.</p>
            <p align=justify>Довольно часто можно столкнуться с ситуацией, когда после ввода команды довольно долго приходиться ждать ответа 
                    удаленной машины, но зато после первого ответа удаленный компьютер начинает реагировать на команды с такой же скоростью, как и 
                    ваш собственный персональный компьютер. В этом случае, скорее всего, в первоначальной задержке виноват сервис доменных имен.</p>
            <p align=justify>Другой пример того же сорта - это программа traceroute. Здесь задержка на запросы к серверу доменных имен проявляется
                     в том, что время ответов со шлюзов, на которых "умирают" ICMP пакеты, указанное в отчете, маленькое, а задержки с отображением 
                     каждой строчки отчета довольно большие.</p>
            <p align=justify>Любопытно, что в системе Windows 3.1 некоторые программы трассировки, показывали сначала IP-адрес шлюза, а 
                   только потом, после разрешения "обратного" запроса, заменяли его на доменное имя шлюза. Если сервис доменных имен работал быстро, 
                   то эта подмена была практически незаметна, но если сервис работал медленно, то промежутки бывали довольно значительными.</p>
            <p align=justify>Проверить на сколько "чувствительны" запросы traceroute c точки зрения отображения трассы к использованию сервера доменных 
                    имен можно задав поиск трассы с использованием сервера:</p>
                    <pre>
                        >traceroute www.w3.org
                    </pre>
                    <p align=justify>и без использования сервера:</p>
                    <pre>
                        >traceroute -n www.w3.org
                    </pre>
            <p align=justify>Если в примере с telnet и ftp мы рассматривали, только "прямые" (forward) запросы к серверу доменных имен, то в примере с traceroute 
                    мы впервые упомянули "обратные"(reverse) запросы. В "прямом" запросе прикладная программа запрашивает у сервера доменных имен IP-адрес, сообщая ему 
                    доменное имя. При "обратном" запросе прикладная программа запрашивает доменное имя, сообщая серверу доменных имен IP-адрес.</p>
             <p align=justify>Следует заметить, что скорость разрешения "прямых" и "обратных" запросов в общем случае будет разная. Все зависит от того, где описаны 
                 "прямые"(forward) и "обратные"(reverse) зоны в базах данных серверов доменных имен, обслуживающих соответствующие домены (прямой и обратный).</p>
            <p align=justify>Более подробно этого вопроса мы коснемся при обсуждении файлов конфигурации программы named.</p>
            <p align=justify>Однако вернемся к обсуждению схемы работы системы доменных имен. Собственно нерекурсивным рассмотренный выше запрос является только 
                с точки зрения сервера. С точки зрения resolver-а процедура разрешения запроса является рекурсивной, так как resolver перепоручил локальному серверу
                доменных имен заниматься поиском необходимой информации. Согласно RFC-1035, resolver и сам может опрашивать удаленные серверы доменных имен и получать 
                от них ответы на свои запросы.</p>
            <p align=justify>В этом случае resolver обращается к локальному серверу доменных имен, если не получает от него адреса, то опрашивает сервер корневого 
                домена, получает от него адрес удаленного сервера TLD, опрашивает этот сервер, получает адрес удаленного сервера, опрашивает удаленный сервер и 
                получает IP-адрес, если он посылал, так называемый "прямой" запрос.</p>
            
            <figure class="sign">                     
            <img src="pic/pic2.jpg">
            <figcaption><i>Рис.2. Нерекурсивный запрос resolver-а.</i></figcaption>
            </figure>

            <p align=justify>Как видно из этой схемы, resolver сам нашел нужный IP-адрес. Однако общая практика такова, что resolver не порождает нерекурсивных 
                запросов, а переадресовывает их локальному серверу доменных имен.</p>
            <p align=justify>Локальный сервер и resolver не все запросы выполняют по указанной процедуре. Дело в том, что существует кэш, который используется для 
                хранения в нем полученной от удаленного сервера информации.</p>
            <p align=justify>Самые умные resolver-ы, такие, например, как resolver Windows 2000 Server и BIND 9 умеют поддерживать кэш, в котором сохранияют не 
                только удачно установленные соответствия имени и адреса (positive response), но и так называемые "негативные" отклики (negative response results) 
                на запросы. Кроме того, эти resolver-ы упорядочивают отклики об адресах серверов в соответствии с принятыми в них (resolver-ах) алгоритмами 
                выставления предпочтений, которые базируются на времени отклика сервера.</p>
            <figure class="sign">
                <img src="pic/pic3.jpg">
                <figcaption><i>Рис.3. Схема разрешения запросов с кэшированием ответов.</i></figcaption>
            </figure>

            <p align=justify>Если пользователь обращается в течение короткого времени к одному и тому же ресурсу сети, то запрос на удаленный сервер не отправляется, 
                а информация ищется в кэше.</p>
                <p align=justify>Вообще говоря, прядок обработки запросов можно описать следующим образом:</p>           
                    <ol>
                    <li>поиск ответа в локальном кэше
                    <li>поиск ответа на локальном сервере
                    <li>поиск информации в сети.
                    </ol>
                <p align=justify>При этом кэш может быть как у resolver-а, так и у сервера.
                <p align=justify>Прежде, чем мы двинемся дальше в нашем понимании работы системы доменных имен введем еще одно понятие - зону.
                <p align=justify>Между доменом и зоной существует разница, которую бывает трудно найти, но всегда нужно иметь в виду. Домен - это все множество 
                    машин, которые относятся к одному и тому же доменному имени. Например, все машины, которые в своем имени имеют постфикс kiae.su относятся к 
                    домену kiae.su. Зона - это "зона ответственности" конкретного сервера доменных имен, т.е. понятие домена шире, чем понятие зоны. Если домен 
                    разбивается на поддомены, то у каждого из них может появиться свой сервер. При этом зоной ответственности сервера более высокого уровня будет 
                    только та часть описания домена, которая не делегирована другим серверам. Разбиение домена на поддомены и организация сервера для каждого из 
                    них называется делегирование прав управления зоной соответствующему серверу доменных имен, или просто делегированием зоны.</p>
                <p align=justify>При настройке сервера, в его файлах конфигурации можно непосредственно прописать адреса серверов зон. В этом случае обращения 
                    к корневому серверу не производятся, т.к. местный сервер сам знает адреса удаленных серверов зон, которым он же и делегировал права управления 
                    этими зонами.</p>
                <p align=justify>Существует еще и другой вариант работы сервера, когда он не запрашивает корневой сервер на предмет адреса удаленного сервера 
                    доменных имен. Это происходит тогда, когда незадолго до этого сервер уже разрешал задачу получения IP-адреса из того же домена. Если требуется 
                    получить IP-адрес удаленного сервера доменных имен, отвечающего за домен, то он будет просто извлечен из буфера сервера (кеша), т.к. в течение 
                    определенного времени, заданного в конфигурации описания зоны (Time To Live - TTL), этот адрес будет храниться в кэше сервера. А попал он туда 
                    как результат выполнения предыдущего запроса.</p>
                <p align=justify>Кроме нерекурсивной процедуры разрешения имен возможна еще и рекурсивная процедура разрешения имен. Ее отличие от описанной 
                    выше нерекурсивной процедуры состоит в том, что удаленный сервер сам опрашивает свои серверы зон, а не сообщает их адреса местному серверу 
                    доменных имен. Рассмотрим этот случай более подробно.</p>
                <p align=justify>На рисунке 4 продемонстрирована нерекурсивная процедура разрешения IP-адреса по доменном имени. Основная нагрузка в этом случае 
                    ложится на местный сервер доменных имен, который осуществляет опрос всех остальных серверов. Для того, чтобы сократить число таких обменов, если 
                    позволяет объем оперативной памяти, можно разрешить буферизацию (кэширование) адресов. В этом случае число обменов с удаленными серверами сократится.</p>
                <p align=justify>На рисунке 5 удаленный сервер домена сам разрешает запрос на получение IP-адреса хоста своего домена по рекурсивному запросу, используя 
                    при этом нерекурсивный опрос своих серверов поддоменов.</p>
                
                <figure class="sign">                           
                <img src="pic/pic4.jpg">
                <figcaption><i>Рис 4. Нерекурсивная обработка запроса местным сервером доменных имен на получение IP-адреса по доменному имени.</i>
                </figcaption></figure>
                <figure class="sign">
                <img src="pic/pic5.jpg">
                <figcaption><i>Рис. 5. Рекурсивная (для местного сервера) и нерекурсивная (для удаленного сервера) процедуры разрешения адреса 
                    по IP-имени.</i></figcaption>
                </figure>
                <p align=justify>При этом локальный сервер сразу получает от удаленного адрес хоста, а не адреса серверов поддоменов. Удаленному серверу при этом должно быть 
                    разрешено обслуживание рекурсивных запрос с соответствующего IP-адреса, местный сервер должен обратиться к удаленному с рекурсивным запросом.</p>
                    <p align=justify>Представленные здесь варианты работы системы доменных имен не являются исчерпывающими. За более подробной информацией следует обращаться 
                        к RFC-1034 и RFC-1035.</p>
                        
                        
                        
                        
        <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>                   
</div>
</body>
</html> 